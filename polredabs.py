from sage.all import *

def is_prim_pol(f, p):
    """
    is pol irreducible and primitive?

    TESTS:

        sage: R.<x> = PolynomialRing(GF(7))
        sage: f = x^3 + 3*x + 2  # primitive
        sage: is_prim_pol(f, 7)
    """
    Fp = GF(p)
    R = PolynomialRing(Fp, 'x'); x = R.gen()
    m = f.degree()

    if not f.is_irreducible():
        return False

    K.<a> = GF(p**m, modulus=f)

    return a.multiplicative_order() == p**m - 1

def unram_pol_jr(m, p):
    """

    TESTS:

        sage: pol = unram_pol_jr(3, 5)
        sage: pol
    """
    # returns primitive polynomial of degree m over F_p
    RZ = PolynomialRing(ZZ, 'x'); x = RZ.gen()
    pol = x**m

    done = False
    while not done:
        j = 0
        s = 1
        # "increment coefficients"
        while pol[j] == (p-1)*s:
            pol -= s*(p-1)*x**j
            s = -s
            j += 1
        pol += s*x**j

        # reduce mod p
        R = PolynomialRing(GF(p), 'x'); xp = R.gen()
        pol_mod_p = R([c % p for c in pol.list()])

        # check primitivity from prev function
        if is_prim_pol(pol_mod_p, p):
            done = True

    return pol_mod_p

def conway_or_jr_polynomial(K, n):
    """
    EXAMPLES:

        sage: K = GF(7)
        sage: pol = conway_or_jr_polynomial(K, 3)
        sage: pol
    """
    if K == K.prime_subfield():
        p = K.characteristic()
        try: # get conway
            F = GF(p**n, name='a', modulus='conway')
            return F.modulus().change_ring(ZZ)
        except (ValueError, RuntimeError):
            # if can't find conway then jr
            return unram_pol_jr(n, p)
    else: # res field
        p = K.characteristic()
        F = GF(p**n, name='a')
        return F.modulus().change_ring(K)


def residue_factor(phi, p):
    """
    EXAMPLES:

        sage: R.<x> = PolynomialRing(GF(7))
        sage: phi = (x^2 + 3*x + 5)^2
        sage: nu = residue_factor(phi,7)
        sage: phi, nu
    """
    RZ = phi.parent()
    Fp = GF(p)
    Rp.<x> = PolynomialRing(Fp)
    coeffs_mod_p = [c % p for c in phi.list()]
    Rphi = Rp(coeffs_mod_p)

    if Rphi.is_zero():
        return 0

    facs = Rphi.factor()
    if len(facs) != 1:
        return 0

    nu = facs[0][0] #irreducible

    RZ.<X> = PolynomialRing(ZZ)
    lifted = RZ([int(c) for c in nu.list()])

    return lifted


def is_eisenstein_form(phi, p):
    """
    sage vers of Magma's IsEisensteinForm

    EXAMPLES:

        sage: K = Qp(5)
        sage: R.<x> = PolynomialRing(K)
        sage: phi = x^4 + x^3 + x^2 + x + 1
        sage: is_eisenstein_form(phi, 5) # should be yes
    """
    R = phi.parent()
    if R.base_ring() != ZZ: # check the coefficient ring
        return False

    coef = phi.list()
    n = len(coef)

    # check monic
    if coef[-1] != 1:
        return False

    # check divisibility conditions
    if any(c % p != 0 for c in coef[:-1]):
        return False

    # constant term divisible by p but not p^2
    if coef[0] % (p**2) == 0:
        return False

    return True

def eisenstein_form(L, K):
    """
    A generating polynomial phi in K[x] of L in Eisenstein form along with
  the polynomial nu generating the unramified subextensions of L/K and gamma with phi(gamma) = 0.
    """

    R.<t> = PolynomialRing(L)
    pi = L.uniformizer()

    if L.inertia_degree() == L.degree():
        n = L.inertia_degree()
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        phi = L.defining_polynomial()
        alpha = (R(nu - pi)).roots(multiplicities=False)[0]
        return nu, nu, alpha

    elif L.ramification_index() == L.degree():
        phi = L.defining_polynomial()
        return phi, PolynomialRing(K).gen(), L.gen()

    else:
        n = L.inertia_degree()
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        gamma = (R(nu - pi)).roots(multiplicities=False)[0]
        phi = gamma.minpoly(K)
        return phi, nu, gamma

def EisensteinForm_poly(f, K):
    """
    Given f irreducible, return a polynomial g in Eisenstein form such that K[x]/(g) is isomorphic to 
  the extension of generated by f.
    """
    
    RL = L.residue_field()
    f = f.change_ring(L)  

    if is_eisenstein_form(f):
        ext = L.extension(f, 'alpha')
        return eisenstein_form(ext, K)

    elif f.change_ring(RL).is_irreducible():
        U = L.extension(f, 'beta', names=('beta',))
        return eisenstein_form(U, K)

    else:
        fac = f.change_ring(RL).factor()

        residue_deg = fac[0][0].degree()
        U = L.extension(conway_or_jr_polynomial(L.prime_subfield(), residue_deg), 'u')

        fac2 = f.change_ring(U).factor()
        Ls = [U.extension(g[0], 'zeta') for g in fac2]
        return eisenstein_form(Ls[0], K)

def EisensteinForm_simple(f):
    K = f.base_ring()
    return EisensteinForm_poly(f, K)

def residual_polynomial_of_component_abs(phi, nu, alpha, m):
    """
   The residual polynomial of the segment of the ramfication polygon of phi of slope -m and the Hasse Herbrand function of phi at m. 
   alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}

    EXAMPLES::

        sage: p = 3
        sage: prec = 20
        sage: K = Qp(p, prec)
        sage: R.<x> = K[]

        sage: phi = x^2 - 3 # irreducible and eisenstein
        sage: alpha_field = K.extension(phi, names='x')
        sage: alpha = alpha_field.gen()

        sage: nu = x
        sage: m = 1

        sage: Sm, cont = residual_polynomial_of_component_abs(phi, nu, alpha, m)
        sage: print(Sm, ",", cont)
    """
    L = alpha.parent()
    LX = L['X']; X = LX.gen()

    rho = (phi.change_ring(L)).subs(X + alpha)

    nualpha = nu(alpha)

    RL = L.residue_field()
    RLz = RL['z']; z = RLz.gen()

    rhom = rho.subs(X=nualpha**m * X)

    # Min valuation
    coeff_vals = [c.valuation() for c in rhom.list() if c != 0]
    cont = min(coeff_vals)

    rdpc = rhom / (nualpha**cont)

    coeffs = [c.residue() for c in rdpc.list()]
    Sm = sum(coeffs[i] * z**i for i in range(len(coeffs)))

    return RLz(Sm), cont



def ResidualPolynomial(phi, nu, alpha):
    """
    The residual polynomials of the segments of the ramfication polygon of phi.
alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha
    """
    rp, rho = RamificationPoly(phi, alpha)   # have to make func for this
    LX = rho.parent()
    L = LX.base_ring()
    nualpha = nu(alpha)

    RL, lift = L.residue_field()
    RLz.<z> = RL[]

    slopes = [-m for m in reversed(LowerSlopes(rp))]
    vertices = list(reversed(LowerVertices(rp)))

    A = []

    for l in range(len(slopes)):
        m = slopes[l]
        i, vri = vertices[l]
        j, vrj = map(int, vertices[l+1])  # integerize

        t = m.numerator()
        d = m.denominator()

        a = sum(
            lift(Coefficient(rho, k*d + j) / (nualpha ** (vrj - k*t))) * z**k
            for k in range(int((i - j) / d) + 1)
        )
        A.append(a)

    return A
