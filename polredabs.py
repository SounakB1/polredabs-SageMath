from sage.all import *

def is_prim_pol(f, p):
    """
    is pol irreducible and primitive?
    """
    Fp = GF(p)
    R = PolynomialRing(Fp, 'x'); x = R.gen()
    m = f.degree()

    if not f.is_irreducible():
        return False

    K.<a> = GF(p**m, modulus=f)

    return a.multiplicative_order() == p**m - 1

R.<x> = PolynomialRing(GF(7))
f = x^3 + 3*x + 2  # primitive
print(is_prim_pol(f, 7))

def unram_pol_jr(m, p):
    # returns primitive polynomial of degree m over F_p
    RZ = PolynomialRing(ZZ, 'x'); x = RZ.gen()
    pol = x**m

    done = False
    while not done:
        j = 0
        s = 1
        # "increment coefficients"
        while pol[j] == (p-1)*s:
            pol -= s*(p-1)*x**j
            s = -s
            j += 1
        pol += s*x**j

        # reduce mod p
        R = PolynomialRing(GF(p), 'x'); xp = R.gen()
        pol_mod_p = R([c % p for c in pol.list()])

        # check primitivity from prev function
        if is_prim_pol(pol_mod_p, p):
            done = True

    return pol_mod_p

pol = unram_pol_jr(3, 5)
print(pol)

def conway_or_jr_polynomial(K, n):
    if K == K.prime_subfield():
        p = K.characteristic()
        try: # get conway
            F = GF(p**n, name='a', modulus='conway')
            return F.modulus().change_ring(ZZ)
        except (ValueError, RuntimeError):
            # if can't find conway then jr
            return unram_pol_jr(n, p)
    else: # res field
        p = K.characteristic()
        F = GF(p**n, name='a')  
        return F.modulus().change_ring(K)

K = GF(7)
pol = conway_or_jr_polynomial(K, 3)
print(pol)

def residue_factor(phi, p):
    RZ = phi.parent()
    Fp = GF(p)
    Rp.<x> = PolynomialRing(Fp)
    coeffs_mod_p = [c % p for c in phi.list()]
    Rphi = Rp(coeffs_mod_p)

    if Rphi.is_zero():
        return 0
        
    facs = Rphi.factor()
    if len(facs) != 1:
        return 0

    nu = facs[0][0] #irreducible

    RZ.<X> = PolynomialRing(ZZ)
    lifted = RZ([int(c) for c in nu.list()])

    return lifted

R.<x> = PolynomialRing(GF(7))
phi = (x^2 + 3*x + 5)^2
nu = residue_factor(phi,7)
print(phi, nu)

def is_eisenstein_form(phi, p):
    """
    sage vers of Magma's IsEisensteinForm
    """
    R = phi.parent()
    if R.base_ring() != ZZ: # check the coefficient ring
        return False

    coef = phi.list()
    n = len(coef)

    # check monic
    if coef[-1] != 1:
        return False

    # check divisibility conditions
    if any(c % p != 0 for c in coef[:-1]):
        return False

    # constant term divisible by p but not p^2
    if coef[0] % (p**2) == 0:
        return False

    return True

K = Qp(5) 
R.<x> = PolynomialRing(K)
phi = x^4 + x^3 + x^2 + x + 1
print(is_eisenstein_form(phi, 5)) # should be yes

def eisenstein_form(L, K):
    """
    A generating polynomial phi in K[x] of L in Eisenstein form along with 
  the polynomial nu generating the unramified subextensions of L/K and gamma with phi(gamma) = 0.
    """

    R.<t> = PolynomialRing(L)
    pi = L.uniformizer()

     if L.inertia_degree() == L.degree():
        n = L.inertia_degree()
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        phi = L.defining_polynomial()
        alpha = (R(nu - pi)).roots(multiplicities=False)[0]
        return nu, nu, alpha

    elif L.ramification_index() == L.degree():
        phi = L.defining_polynomial()
        return phi, PolynomialRing(K).gen(), L.gen()

    else:
        n = L.inertia_degree()
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        gamma = (R(nu - pi)).roots(multiplicities=False)[0]
        phi = gamma.minpoly(K)
        return phi, nu, gamma

def EisensteinForm_poly(f, K):
    """
    Given f irreducible, return a polynomial g in Eisenstein form such that K[x]/(g) is isomorphic to 
  the extension of generated by f.
    """
    
    RL = L.residue_field()
    f = f.change_ring(L)  

    if is_eisenstein_form(f):
        ext = L.extension(f, 'alpha')
        return eisenstein_form(ext, K)

    elif f.change_ring(RL).is_irreducible():
        U = L.extension(f, 'beta', names=('beta',))
        return eisenstein_form(U, K)

    else:
        fac = f.change_ring(RL).factor()

        residue_deg = fac[0][0].degree()
        U = L.extension(conway_or_jr_polynomial(L.prime_subfield(), residue_deg), 'u')

        fac2 = f.change_ring(U).factor()
        Ls = [U.extension(g[0], 'zeta') for g in fac2]
        return eisenstein_form(Ls[0], K)

def EisensteinForm_simple(f):
    K = f.base_ring()
    return EisensteinForm_poly(f, K)
