from sage.all import *

def discrete_log(a):
    return dilog(a)

def is_prim_pol(f, p):
    """
    is pol irreducible and primitive?

    TESTS:

        sage: R.<x> = PolynomialRing(GF(7))
        
        sage: f = x^3 + 3*x + 2  # primitive
        sage: is_prim_pol(f, 7)

        sage: f = x^2 + 3 # reducible
        sage: is_prim_pol(f, 7)

        sage: f = x^2 + 1 # irreducible but not primitive
    """
    Fp = GF(p)
    R = PolynomialRing(Fp, 'x')
    x = R.gen()
    m = f.degree()

    if not f.is_irreducible():
        return False

    K.<a> = GF(p**m, modulus=f)

    return a.multiplicative_order() == p**m - 1

def unram_pol_jr(m, p):
    """
    TESTS:

        sage: pol = unram_pol_jr(3, 5)
        sage: pol

    """
    # returns primitive polynomial of degree m over F_p
    RZ = PolynomialRing(ZZ, 'x')
    x = RZ.gen()
    pol = x**m

    done = False
    while not done:
        j = 0
        s = 1
        # "increment coefficients"
        while pol[j] == (p-1)*s:
            pol -= s*(p-1)*x**j
            s = -s
            j += 1
        pol += s*x**j

        # reduce mod p
        R = PolynomialRing(GF(p), 'x')
        xp = R.gen()
        pol_mod_p = R([c % p for c in pol.list()])

        # check primitivity from prev function
        if is_prim_pol(pol_mod_p, p):
            done = True

    return pol_mod_p

def conway_or_jr_polynomial(K, n):
    """
    Return a Conway (or fallback JR) polynomial of degree n.

    EXAMPLES:
        sage: K = GF(7)
        sage: pol = conway_or_jr_polynomial(K, 3)
        sage: pol
    """
    p = K.characteristic()
    F = GF(p**n, name='a')
    return F.modulus().change_ring(K)

def residue_factor(phi, p):
    """
    EXAMPLES:

        sage: R.<x> = PolynomialRing(GF(7))
        sage: phi = (x^2 + 3*x + 5)^2
        sage: nu = residue_factor(phi,7)
        sage: phi, nu
    """
    RZ = phi.parent()
    Fp = GF(p)


    #Rp = PolynomialRing(QQ, 'x')
    #x = R.gen(0)

    Rp.<x> = PolynomialRing(Fp)
    coeffs_mod_p = [c % p for c in phi.list()]
    Rphi = Rp(coeffs_mod_p)

    if Rphi.is_zero():
        return 0

    facs = Rphi.factor()
    if len(facs) != 1:
        return 0

    nu = facs[0][0] #irreducible

    RZ.<X> = PolynomialRing(ZZ)
    lifted = RZ([int(c) for c in nu.list()])

    return lifted


def is_eisenstein_form(phi):
    """
    sage vers of Magma's IsEisensteinForm

    EXAMPLES:

        sage: K = Qp(5)
        sage: R.<x> = K[]
        sage: phi = x^4 + x^3 + x^2 + x + 1
        sage: is_eisenstein_form(phi, 5) # should be yes

        # from polredabs.m

        sage: K = Qp(3)
        sage: R.<X> = K[]
        sage: phi = x^6 + 246*x^4 + 84*x + 30
        sage: is_eisenstein_form(phi, 3)
    """
    K = phi.base_ring()
    R = phi.parent()
    coef = phi.list()
    p = K.uniformizer()
    
    if (not phi.is_monic()) or any(c % p == 0 for c in coef[:-1]) or coef[0] % (p**2) == 0:
        return False

    return True

def eisenstein_form(L, K):
    """
    A generating polynomial phi in K[x] of L in Eisenstein form along with
    the polynomial nu generating the unramified subextensions of L/K and gamma with phi(gamma) = 0.

    EXAMPLES:
        sage: K = Qp(5, prec = 5)
        sage: R.<x> = K[]
        sage: f = x^2-5
        sage: L.<a> = K.extension(f)
        sage: phi, nu, gamma = eisenstein_form(L, K)
        sage: phi, nu, gamma, phi(gamma)
    """
    R = PolynomialRing(L, 't')
    t = R.gen()
    pi = L.uniformizer()

    if L.inertia_degree() == L.degree():
        n = L.inertia_degree()
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        phi = L.defining_polynomial()
        alpha = (R(nu - pi)).roots(multiplicities=False)[0]
        return nu, nu, alpha

    elif L.ramification_index() == L.degree():
        phi = L.defining_polynomial()
        Rk = PolynomialRing(K, 'x')
        x = Rk.gen()
        return phi, x, L.gen()

    else:
        n = L.inertia_degree()  
        nu = Polynomial(K, conway_or_jr_polynomial(PrimeRing(K), n))
        gamma = (R(nu - pi)).roots(multiplicities=False)[0]
        phi = gamma.minpoly(K)
        return phi, nu, gamma

def EisensteinForm_poly(f, K):
    """
    Given f irreducible, return a polynomial g in Eisenstein form such that K[x]/(g)
    is isomorphic to the extension generated by f.
    """
    L = K

    RL = L.residue_field()
    f = f.change_ring(L)
    if is_eisenstein_form(f):
        ext = L.extension(f, 'alpha')
        return f

    if f.change_ring(RL).is_irreducible():
        U = L.extension(f, 'beta', names=('beta',))
        return eisenstein_form(U, K)

    fac = f.change_ring(RL).factor()
    residue_deg = fac[0][0].degree()

    poly_for_U = conway_or_jr_polynomial(RL, residue_deg)
    U = L.extension(poly_for_U, 'u')

    fac2 = f.change_ring(U).factor()
    Ls = [U.extension(g[0], 'zeta') for g in fac2]
    return eisenstein_form(Ls[0], K)

def EisensteinForm_simple(f):
    K = f.base_ring()
    return EisensteinForm_poly(f, K)

def residual_polynomial_of_component_abs(phi, nu, alpha, m):
    """
   The residual polynomial of the segment of the ramfication polygon of phi of slope -m and the Hasse Herbrand function of phi at m. 
   alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}

    EXAMPLES:

        sage: p = 3
        sage: prec = 20
        sage: K = Qp(p, prec)
        sage: R.<x> = K[]

        sage: phi = x^2 - 3 # irreducible and eisenstein
        sage: alpha_field = K.extension(phi, names='x')
        sage: alpha = alpha_field.gen()

        sage: nu = x
        sage: m = 1

        sage: Sm, cont = residual_polynomial_of_component_abs(phi, nu, alpha, m)
        sage: print(Sm, ",", cont)
    """
    L = alpha.parent()
    LX = L['X']
    X = LX.gen()

    rho = (phi.change_ring(L)).subs(X + alpha)

    nualpha = nu(alpha)

    RL = L.residue_field()
    RLz = RL['z']
    z = RLz.gen()

    rhom = rho.subs(X=nualpha**m * X)

    # Min valuation
    coeff_vals = [c.valuation() for c in rhom.list() if c != 0]
    cont = min(coeff_vals)

    rdpc = rhom / (nualpha**cont)

    coeffs = [c.residue() for c in rdpc.list()]
    Sm = sum(coeffs[i] * z**i for i in range(len(coeffs)))

    return RLz(Sm), cont

def RamificationPoly(phi, alpha, nu=None):
    """
    Return the ramification polynomial of phi at alpha.
    """

    if nu is None:
        R = parent(phi)
        x = R.gen()
        nu = x
    
    n = phi.degree()
    nualpha = nu(alpha)

    # formula: rho(x) = phi(alpha + x*nualpha) / nualpha^n
    R.<x> = PolynomialRing(alpha.parent())
    rho = phi(alpha + x*nualpha) / (nualpha**n)

    rp = rho # modified later

    return rp, rho

def LowerSlopes(f):
    np = f.newton_polygon()
    return [slope for slope, _ in np.lower_slopes()]

def LowerVertices(f):
    np = f.newton_polygon()
    return np.lower_vertices()

def ResidualPolynomialOfComponentAbs(phi, nu, alpha, m):
    """
    The residual polynomial of the segment of the ramfication polygon of phi of slope -m and the
    Hasse Herbrand function of phi at m. alpha is a root of phi and nu(alpha) a uniformizing element 
    in the extensions generated by alpha.

    EXAMPLES:
        sage: p = 3
        sage: prec = 20
        sage: K = Qp(p, prec)
        sage: R.<x> = K[]
        sage: phi = x^2 - 3
        sage: L.<a> = K.extension(phi)
        sage: nu = x
        sage: m = 1
        sage: Sm, cont = ResidualPolynomialOfComponentAbs(phi, nu, a, m)
        sage: print(Sm, " ", cont)
    """
    # Ramification Poly
    rp, rho = RamificationPoly(phi, alpha)
    LX = rho.parent()
    L = LX.base_ring()
    X = LX.gen()

    nualpha = nu(alpha)
    rhom = rho.subs(X=nualpha**m * X)

    # Min valuation
    coeffs = rhom.list()
    coeff_vals = [c.valuation() for c in coeffs if c != 0]
    cont = min(coeff_vals)

    rdpc = rhom / (nualpha**cont)

    # Coefs go to res field
    RL = L.residue_field()
    RLz = RL['z']
    z = RLz.gen()
    coeffs_res = [c.residue() for c in rdpc.list()]

    # Res polynomial
    Sm = sum(coeffs_res[i] * z**i for i in range(len(coeffs_res)))

    return RLz(Sm), cont

def ResidualPolynomial(phi, nu, alpha):
    """
    The residual polynomials of the segments of the ramfication polygon of phi.
alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha

    EXAMPLES:

    sage: K = Qp(5, prec=60)
    sage: R.<x> = K[]
    sage: phi = x^3 - 5
    sage: L.<alpha> = K.extension(phi)
    sage: nu = x

    sage: residuals = ResidualPolynomial(phi, nu, alpha)
    sage: for i, r in enumerate(residuals): print(f"Segment {i}: {r}")
    """
    rp, rho = RamificationPoly(phi, alpha)   # have to make func for this
    LX = rho.parent()
    L = LX.base_ring()
    nualpha = nu(alpha)

    RL, lift = L.residue_field()
    RLz.<z> = RL[]

    slopes = [-m for m in reversed(LowerSlopes(rp))]
    vertices = list(reversed(LowerVertices(rp)))

    A = []

    for l in range(len(slopes)):
        m = slopes[l]
        i, vri = vertices[l]
        j, vrj = map(int, vertices[l+1])  # integerize

        t = m.numerator()
        d = m.denominator()

        a = sum(lift(Coefficient(rho, k*d + j) / (nualpha ** (vrj - k*t))) * z**k for k in range(int((i - j) / d) + 1))
        A.append(a)

    return A

def Distinguished(M, nu=None):
    """
    Given a set of reduced polynomials in Eisenstein form, return a distinguished polynomial.

    EXAMPLES:
    sage: K = Qp(5,prec=20)
    sage: R.<x> = K[]
    
    sage: phi1 = x^3 + 5*x + 5
    sage: phi2 = x^3 + 10*x + 5
    sage: phi3 = x^3 + 15*x + 5

    sage: M = {phi1, phi2, phi3}
    sage: phi_dist = Distinguished(M)
    sage: print(phi_dist)

    """
    
    L = list(M)
    R = parent(L[0])
    x = R.gen()
    
    # Determine nu
    K = L[0].base_ring()
    p = K.prime()  # uniformizer prime
    if is_eisenstein_form(L[0]):
        nu = x
    elif nu is None:
        nu = residue_factor(L[0], p)
    
    # Comparator key: evaluate expansion coefficients at p
    def sort_key(f):
        exp_coeffs = f.list()
        return tuple([c for c in exp_coeffs])

    # Sort L by the key
    L.sort(key=sort_key)
    return L[0]

def ResidualPolynomialClasses(phi, with_trans=False, conjugates=False):
    """
    The residual polynomial classes of an Eisenstein polynomial phi.
    
    EXAMPLES:
    sage: K = Qp(3, prec=20)
    sage: R.<x> = K[]
    sage: phi = x^2 - 3

    sage: ResidualPolynomialClasses(phi)
    """

    # Conj Eisenstein Form
    if not is_eisenstein_form(phi):
        conjugates = True
        phiE = EisensteinForm_simple(phi)
        # depending on what is returned by eisenstein form
        if isinstance(phiE, tuple) or isinstance(phiE, list):
            phi = phiE[0]
        else:
            phi = phiE

    Kx = phi.parent()
    K = phi.base_ring()
    RK, KtoRK = K.residue_field()
    n = phi.degree()

    def residual_polynomial_classes_sub(phi, with_trans):
        invA = set()
        for delta in RK:
            if delta != 0:
                deltaK = K(delta)
                phidelta = Kx([phi.coefficient(i) * deltaK**(n - i) for i in range(n + 1)])
                if with_trans:
                    res_poly = ResidualPolynomial(phidelta, Kx.gen(), phidelta.roots()[0][0])
                    invA.add((res_poly, phidelta, delta))
                else:
                    res_poly = ResidualPolynomial(phidelta, Kx.gen(), phidelta.roots()[0][0])
                    invA.add(res_poly)
        return invA

    if not conjugates:
        return residual_polynomial_classes_sub(phi, with_trans)
    else:
        invA = set()
        auts = K.automorphisms()
        for tau in auts:
            tauphi = Kx([tau(c) for c in phi.coefficients(sparse=False)])
            invA |= residual_polynomial_classes_sub(tauphi, with_trans)
        return invA

def PolynomialCompareLog(f, g):
    """
    Compare two polynomials f and g over a local field by comparing the
    discrete logarithms of their coefficients in lexicographic order
    (starting from the leading coefficient).

    EXAMPLES:
    
    sage: K = Qp(3, prec=10) 
    sage: R.<x> = K[]

    sage: f = x^2 + 3*x + 1
    sage: g = x^2 + 3*x + 2

    sage: res = PolynomialCompareLog(f,g)
    sage: print(res)
    """
    if f.degree() != g.degree():
        raise ValueError("Polynomials must have the same degree.")
    for i in reversed(range(f.degree() + 1)):
        a, b = f[i], g[i]
        if a == 0 and b != 0:
            return -1
        elif b == 0 and a != 0:
            return 1
        elif a != 0 and b != 0 and a != b:
            return discrete_log(a) - discrete_log(b)
    return 0

def ResidualPolynomialCompare(A, B):
    """
    Return 1 if A > B, -1 if A < B, 0 otherwise.

    EXAMPLES:

    sage: R.<x> = PolynomialRing(GF(7))

    sage: A = [x^2 + 3*x + 1, x^3 + 2]
    sage: B = [x^2 + 3*x + 1, x^3 + 3]

    sage: print(ResidualPolynomialCompare(A,B))
    """

    if len(A) != len(B):
        raise ValueError("ResidualPolynomialCompare: Lists of residual polynomials must be of the same length.")

    for a, b in zip(A, B):
        c = PolynomialCompareLog(a, b)
        if c != 0:
            return c

    return 0

def Expansion(f, nu):
    """
    The coefficients of the nu-expansion of f as a list.
    """
    expansion = []
    while f != 0:
        a = f % nu
        expansion.append(a)
        f = (f - a) // nu
    return expansion


def Contraction(L, nu):
    """
    Given list L = [a0, a1, ..., ak] of coefficients
    and polynomial nu, reconstruct poly.
    """
    return sum(L[i] * nu**i for i in range(len(L)))


# Inner Function for ResPolyDistinguished

def residual_polynomial_distinguished_sub(thisphi, constant_first=constant_first):
    if constant_first:
        phi0 = thisphi.coefficient(0)
        try:
            phi01 = KtoFq(phi0 // piK)  
        except Exception:
            phi01 = KtoFq(phi0 / piK)
        a = discrete_log(phi01)  
        y = Integer(thisphi.degree())
        d, s0, _ = xgcd(y, q - 1)
        k = Integer(a) // Integer(d)
        t0 = Integer((-s0 * k) % (q - 1))
        Delta = Integer((q - 1) // d)
        x_base = [Integer(t0)]
    else:
        Delta = Integer(1)
        x_base = [Integer(0)]
